from datetime import datetime, timedelta
from hypothesis import given, strategies as st
from hypothesis.strategies import composite
from nurserostering.data_schema import NurseRosteringInstance, Shift, Nurse
from nurserostering.solver import NurseRosteringModel
from nurserostering.validation import assert_solution_is_feasible


# --- Helper strategies ---

# A datetime in Jan 2025
_dt_jan_2025 = st.datetimes(
    min_value=datetime(2025, 1, 1, 0, 0, 0),
    max_value=datetime(2025, 1, 31, 23, 59, 59),
)


@composite
def shift_strategy(draw):
    """
    Build a Shift with end_time > start_time.
    """
    name = draw(st.text(min_size=1, max_size=10))
    start = draw(_dt_jan_2025)

    # Duration between 4h and 12h
    duration_hours = draw(st.integers(min_value=4, max_value=12))
    end = start + timedelta(hours=duration_hours)

    # Demand can be zero per schema (NonNegativeInt); keep small
    demand = draw(st.integers(min_value=0, max_value=3))

    # uid is auto-generated by schema default_factory
    return Shift(
        name=name,
        start_time=start,
        end_time=end,
        demand=demand,
    )


def _subset_of_uids(shift_uids, max_size=5):
    """
    Produce a strategy for a set subset of the given shift_uids.
    """
    # sampled_from requires a sequence, not a set
    return st.sets(
        st.sampled_from(list(shift_uids)),
        max_size=max_size,
    )


@composite
def nurse_strategy(draw, shift_uids):
    """
    Build a Nurse whose preferred/blocked sets are subsets of the provided shift_uids.
    """
    name = draw(st.text(min_size=1, max_size=10))
    staff = draw(st.booleans())
    min_tbs = timedelta(hours=8)  # fixed, as in your original
    pref_weight = draw(st.integers(min_value=0, max_value=5))  # NonNegativeInt

    # Independent subsets; may overlap (schema does not forbid)
    preferred = draw(_subset_of_uids(shift_uids, max_size=5))
    blocked = draw(_subset_of_uids(shift_uids, max_size=5))

    # uid is auto-generated by schema default_factory
    return Nurse(
        name=name,
        preferred_shifts=preferred,
        blocked_shifts=blocked,
        staff=staff,
        min_time_between_shifts=min_tbs,
        preferred_shift_weight=pref_weight,
    )


@composite
def instance_strategy(draw):
    """
    Build a NurseRosteringInstance that passes all schema validators:
    - Unique nurse/shift UIDs (handled by defaults).
    - Shifts sorted by start_time.
    - Nurses' preference/blocked sets reference existing shift UIDs.
    """
    # Make and sort shifts by start_time
    num_shifts = draw(st.integers(min_value=10, max_value=20))
    shifts = [draw(shift_strategy()) for _ in range(num_shifts)]
    shifts.sort(key=lambda s: s.start_time)

    shift_uids = [s.uid for s in shifts]

    # Build nurses referencing these shift_uids
    num_nurses = draw(st.integers(min_value=5, max_value=10))
    nurses = [draw(nurse_strategy(shift_uids)) for _ in range(num_nurses)]

    staff_weight = draw(st.integers(min_value=0, max_value=5))

    return NurseRosteringInstance(
        nurses=nurses,
        shifts=shifts,
        staff_weight=staff_weight,
    )


# --- Property test ---


@given(instance=instance_strategy())
def test_solver_finds_feasible_solution(instance):
    model = NurseRosteringModel(instance)
    try:
        solution = model.solve(max_time_in_seconds=10.0)
        assert_solution_is_feasible(instance, solution)
    except ValueError:
        # If the model is infeasible, we accept that as a valid outcome.
        # Ensuring that the input is feasible would be a little more complex.
        pass


@given(st.lists(st.integers()))
def test_sort_preserves_length_and_order(xs):
    print(xs)
    sorted_xs = sorted(xs)

    # Property 1: Sorting does not change the length
    assert len(sorted_xs) == len(xs)

    # Property 2: Sorted list is monotonically non-decreasing
    for a, b in zip(sorted_xs, sorted_xs[1:]):
        assert a <= b
